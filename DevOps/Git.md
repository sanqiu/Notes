Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-08-22T10:19:15+08:00

====== Git ======
Created Friday 22 August 2014

== Concepts ==
refspec  COMMITS/ SHA-1
HEAD : this is a pointer to the local branch you are currentlu on. ##  stores in .git/HEAD

If a particular version of a file is in the git directory, it’s considered commi ed. If it’s modified but has been added to the staging area, it is staged. And if it was changed since it was checked out but has not been staged, it is modified.

You’ll notice the phrase “**Fast-forward**” in that merge. Because the commit pointed toby the branch you merged in was directly upstream of the commit you’re on, Git moves thepointer forward. To phrase that another way, when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things bymoving the pointer forward because there is no divergent work to merge together — this is
called a “fast forward”.

Git has three main states that your files can reside in: commi ed, modified, and staged. Commi ed means that the data is safely stored in your local database. Modified means that you have changed the file but have not commi ed it to your database yet. Staged means that you have marked a modified file in its current version to go into your next commit snapshot

Chained together UNIX style or called from scripts. These commands are generally referred to as “plumbing” commands, and the more user-friendly commands are called “porcelain” commands.

== Note ==
note that if your working directory or staging area has uncommi ed changes that conflict with the branch you’re checking out, Git won’t let you switch branches.
		use git stash or git commit -amend to get around


== Hooks ==
The pre-commit hook is run first, before you even type in a commit message.
The prepare-commit-msg hook is run before the commit message editor is fired up but after the default message is created. It lets you edit the default message before the commit author sees it

== Before commiting ==
git diff --check
git add --patch
git commit ## frst_line < 50,blank line,lines <72 charas


== git add ==
 1) add files to index, tracking content
 2)add files to staged for committing
 3)mark conflicting files as resolved and committing
-n --dry-run just test files added or ignored ?
-p patch partial 
git add -i ## interactive
git reset [--soft || --hard ||mixed ]head(^2)  ## to undo what is git added

== git apply ==
git apply file.path ## generated by a diff program, not auto cimmit
git apply --check file.patch

== git am ==
git am file.path ## auto commit path files from git send-email
git am --resolved --skip --abort

== git archive ==
--format=zip|tar --output=file.name  --remote=ssh://host/pathto/repo.git [HEAD] file.path ## get/download only one file
git archive --format=zip HEAD > archive.zip

== git bisect ==

== git blame ==
-L 20,56 ## from lines 20-56

== git branch ==
default : create a branch based on the current commit,but don't switch to that branch.
--merged //  --no-merged
-a all show all branches
-r show only remote branches

== git cat-file ==
-p show contents of a **objects in .git/objects**

== git checkout ==
default switch to the defined branch,moving the HEAD pointer to the defined branch
**!! from stash to working tree without HEAD, from head to working tree IF with HEAD**
git checkout FETCH_HEAD -- {file} **##pull only one files**
git checkout -- file ## revert file which is in stash but not committed yet to working tree

== git cherry-pick ==

== git  clean ==
clean untracked files
-f files
-d directories

== git clone ==
git checkout HEAD -- file 
git checkout -b serverfix origin/serverfix == git checkout --track origin/serverfix

== git commit ==
-a auto add changed files
-o only current dir
--dry-run
--amend -c [reedit] [commit id| HEAD~123]
--amend -C [keep that message] [commit id | HEAD~123]


== git config ==
--list configs
--edit configs with $EDITOR
--add name val
--replace-all name val-regex
--get name val
--unset name value
--remove-section name
$ git config --global alias.co checkout
git config --global alias.unstage 'reset HEAD --'
git config --global user.signingkey <gpg-key-id>
git config receive.denyNonFastForwards ##try to push a commit to a remote branch that doesn’t contain the commit that the remote
branch currently points to, you’ll be denied

== git count-objects ==
count packs
-v
 -H

== git describe ==
recent tag
git show ## recent log

== git diff ==
the right buffer is the modified version and the left is the compared version.
**none** work tree and index  =>will be  staged
--cached index and head  => will be commited
HEAD tree and head  **push <=> pull**
git difftool
git diff file path
git diff commit1 HEAD~3(reverse count 3)
git diff --stat list changed files
--check

== git fsck ==

== git gc ==
--prune=[date]
--aggressive
--auto
--force  ##even if another gc is running
git prune
git repack
git cont-objects
git fsck

== git fetch ==
git fetch origin 96de5297df870:refs/remotes/origin/foo-commit   ## fetch specific commit 

== git filter-branch ==
 --tree-filter 'rm -f passwords.txt' HEAD ## remove a file called passwords.txt from every snapshot
--all to all branches
git filter-branch --subdirectory-filter trunk HEAD ## make sudirctory [//truk//] be the new git root. the rest commits will be lost 

== git grep ==

== git hash-object ==
git hah-object  ## for decide wheather this file has been changed. just as the sha1sum command in the shell.

== git init ==

== git instaweb ==

== git log ==
--graph --oneline --all
git log --show-signature  
git log -g branch ## with reflog style
git log origin/master~3..experiment^2 ## range selection: all commits reachable by experiment that aren’t reachable by
 master. ## comparison of two branched ## two dots
git log origin/master~3...experiment^2  --left-right## do not show common refs in both ## 3 dots
git log ^refA refB refC  ## show commits in both refB and refC but not in refA.  ## ref = BRANCH / HEAD^N~N / SHA-1  ## comparision ot more than two
-n HEAD~4   previous n from HEAD~4

== git ls-files ==
-c cached files 
-d deleted
 -m modified
-o others untracked files
-i ignored files
-s file.name  ##stage   for finding where is this file in the index ## git hash-objects
--directory
-u unmerged
-k kill ## files need to be remove duto checkout another  branch where this file is to delete
-x exclude


== git merge ==
Focusing on the merged buffer and move cursor to the coresponding conflicts and do the following
diffget RE  // diffget LO //  diffget BA
and then :wqa
+--------------------------------+
| LOCAL  |     BASE     | REMOTE |
+--------------------------------+
|             MERGED             |
+--------------------------------+
LOCAL
A **temporary** file **containing** the contents of the file on the current branch.
BASE
A **temporary** file **containing** the common base for the merge.
REMOTE
A **temporary** file **containing** the contents of the file to be merged.
MERGED
The file containing the conflict markers. Git has performed as much automatic conflict resolution as possible and the state of this file is a 
combination of both LOCAL and REMOTE with conflict markers surrounding anything that Git could not resolve itself. The mergetool should 
write the result of the resolution to this file.

== git mv ==
-f force
-n --dry-run

== git push ==
git push [host] [tagname|--tag]


== git pull ==
default = git fetch+git merge FETCH_HEAD
--stat
--progress

== git reflog ==
## a log of where your HEAD and branch references have been for the last few months.

== git rebase ==
git rebase //with -i can be used to split commits.//
1.git checkout exper # to c3
2.git rebase master (1,collent diffs from both c3. c4. 2,reset master's head to C4. 3,do a fast-forward merge with C4 firt and C3 second)
3.both exper and master's HEAD point to C3 ( the diff from branch-experient here are called pathces).
samples:

{{~/Pictures/rebase1.png}}{{~/Pictures/rebase2.png}}
git rebase -i HEAD~3 ## !!!! amend farther commit messages

== git reset ==
git reset [--soft// --hard//--mixed[default] ## wheather include working tree] HEAD^  ## revert last commited to  the stash
UNDO RESET git reset HEAD@{n} ##n=**TIMES** of operations of
 git reset {HEAD |HEAD^2|HEAD~4}

== git rm ==
git rm --cached file ## remove from stash not from working tree

== git revert ==

== git rev-list ==
--all

== git rev-parse ==
git rev-parse branch ##only show the sha1 of the commit that this branch pointing to

== git revert ==
git revert HEAD,HEAD^,HEAD^2
revert last push

== git show ==
## show detailed log about a specific commit
git show [commit=sha-1 | ]
git show branch ## default to show the last commit details of this branch
git show HEAD@{N} ## Note logs out of history
git show BRANCH~3^2

== git status ==

== git stash ==
##saves dirty state of working directory on a stack of unfinished changes that you can reapply at any time.
list / show / pop / save /store / create / drop
create ## a stash that looks like a commit[OBJECT]
branch [brachname] <stash> ## create branch based on this stash

pop stash pop @{N}
pop <invert> save          apply <invert> save & create  ##weather remove the stash state from stash list

== git submodule ==
project in project: subproject <> superproject
git submodule add 
clone a project with submodule in it: 
	1) git clone
	2)git submodule init ## about confs
	3) git submodule update|| status|| deinit|| ## get submodule's update
	4)git submodule add --name name  <repo's url> [path]


== git tag ==
-a annotation|[space] lightweight | -s signoff  -m "tag message"
-l "tags*" list
-a "message" COMMIT


== git update-index ==
--refresh
--really-rfresh
--  [file]

== gitk ==

== Reversion ==
modified but not staged,  git checkout -- file  to discard changes in working directory
modified and staged and want to discard changes use git checkout HEAD — file
modified and staged ,git reset HEAD  file  to unstage
{{../../Pic/git-stage.png}}


Not Index
Modified, not staged

	Modified,staged,not commited
	
		Modified,staged,and commited

~ branch sepecific
^commit specific
G   H   I   J
 \ /     \ /
  D   E   F
   \  |  / \
	\ | /   |
	 \|/    |
	  B     C
	   \   /
		\ /
		 A
A =      = A^0
B = A^   = A^1     = A~1
C = A^2  = A^2
D = A^^  = A^1^1   = A~2
E = B^2  = A^^2
F = B^3  = A^^3
G = A^^^ = A^1^1^1 = A~3
H = D^2  = B^^2    = A^^^2  = A~2^2
I = F^   = B^3^    = A^^3^
J = F^2  = B^3^2   = A^^3^2
